#!/usr/bin/python3

import re
import configparser
import io
import os
import hashlib
import binascii

import settings

class applicationConfig(dict):
    ''' An object capable of storing program configuration (in the form of a dictionnary).
        This class is not generic and is tailored to webGobbler.

        It behaves like a dictionnary object, but it also has
        methods to save/load to/from .INI, file and Windows registry.
        Note that this dictionnary only supports:
          - key which are strings.
          - values which are strings, integers or booleans.
        Using other types will raise errors.
        Some keys are special case (specific (de)serialization).

        Example:
           myconfig = applicationConfig()     # Create a configuration (with default values)
           myconfig["pool.nbimages"] = 100    # Change the value of an existing parameter.
           myconfig["myparameter"] = "toto"   # Add a new parameter
           myconfig.saveToFileInUserHomedir() # save to file.

           conf2 = applicationConfig()
           conf2.loadFromFileInUserHomedir()    # Load previous saved file.
           print conf2["pool.nbimages"]         # This displays 100
           print conf2["myparameter"] = "toto"  # This displays "toto"
           print conf2["pool.keepimages"]
    '''

    # Default configuration:
    # This dictionnary contains the default configuration of the whole program.
    # Each class/thread will read an instance of this class to get its parameters.
    # The instance will be altered by the main() according to command-line parameters.
    # (key=parameter name, value=value of this parameter)


    def __init__(self):
        dict.__init__(self)
        self.data = {}
        self.update( settings.DEFAULTCONFIG ) # Start with default configuration:

    def __setitem(self,key,value):
        if not isinstance(key,str):
            raise TypeError("applicationConfig only accepts strings as keys.")

        self.data[key] = value   # Store the value

        # Recompile the regular expressions if the list of blacklisted URL is changed.
        # (We also bock assignment to blacklist.url_re.)
        if key in ('blacklist.url', 'blacklist.url_re'):
            self.data['blacklist.url_re'] = []
            for s in value:
                # We escape all characters in s, except * which we replace with .+?
                # We also add an implicit .+? at end.
                # Example: 'http://*.xiti.com/'  -->  'http\:\/\/.+?\.xiti\.com\/.+?'
                if not s.endswith('*'):     s += '*'
                s = '.+?'.join([re.escape(ss) for ss in s.split('*')])
                self.data['blacklist.url_re'].append( re.compile(s,re.IGNORECASE) )

    def toINI(self):
        ''' Outputs the configuration as a .INI file.
            Output: a string containing the configuration.
        '''
        cp = configparser.SafeConfigParser()
        cp.add_section(settings.CONFIG_SECTIONNAME)
        # Export all parameters, except the non-exportable ones.
        for key in self:
            if key not in settings.NONEXPORTABLE_PARAMETERS:
                # Serialize some special parameters:
                if key == 'network.http.proxy.auth.password':
                    cp.set(settings.CONFIG_SECTIONNAME,key,self._garble(self[key])) # Garble the password.
                elif key == 'blacklist.imagesha1':  # Serialize the list of blacklisted images
                    cp.set(settings.CONFIG_SECTIONNAME,key,'|'.join(list(self[key].keys())))
                elif key == 'blacklist.url':  # Serialize the list of blacklisted URLs
                    cp.set(settings.CONFIG_SECTIONNAME,key,'|'.join([url.replace('%','%%') for url in self[key]]))
                    # (For ConfigParser, % must be escaped to %%)
                else:  # else, simply store the parameter as is.
                    cp.set(settings.CONFIG_SECTIONNAME,key,str(self[key]))

        # ConfigParser can only write to a file --> create a pseudo-file (inifile)
        inifile = io.StringIO()
        cp.write(inifile)
        data = inifile.getvalue()
        inifile.close()

        # Beautify the file by sorting parameters:
        lines = data.split('\n')
        sectionname = [lines[0]]   # The [webGobbler] section delimiter
        parameters = lines[1:]     # The parameters below
        parameters = [p for p in parameters if len(p.strip())>0]  # remove empty lines generated by configparser
        parameters.sort()
        data = '\n'.join(sectionname+parameters)
        return data

    def fromINI(self, inidata):
        ''' Imports configuration from a .INI file.
            inidata : a string containing the .INI file.
        '''
        inifile = io.StringIO(inidata)
        cp = configparser.SafeConfigParser()
        cp.readfp(inifile)  # FIXME: try/catch ConfigParser exceptions ?
        for (name, value) in cp.items(settings.CONFIG_SECTIONNAME):

            doCoerceType = True
            if name == 'blacklist.imagesha1':
                # Deserialize the list of sha1  (  'xxxx,yyy,zzz' --> ['xxx','yyy','zzz'])
                value = dict([ (v,0) for v in value.split('|')])
                doCoerceType = False  # We already manually coerced the type of this parameter.
            elif name == 'blacklist.url':
                # Deserialize the list of URLs
                value = value.split('|')
                doCoerceType = False  # We already manually coerced the type of this parameter.

            if name in settings.DEFAULTCONFIG and doCoerceType:
                # If parameter exists in default parameters, coerce its type.
                defaultvalue = settings.DEFAULTCONFIG[name]
                obj = None
                try:
                    if isinstance(defaultvalue,str): obj = str(value).strip()
                    elif isinstance(defaultvalue,bool):
                        if str(value).lower()=='true': obj = True
                        else: obj = False
                    elif isinstance(defaultvalue,int):  obj = int(value)
                    elif isinstance(defaultvalue,float):  obj = float(value)
                    elif isinstance(value,dict): raise NotImplementedError("applicationConfig.fromINI() : serialization of dictionnary objects is not implemented.")
                    elif isinstance(value,list): raise NotImplementedError("applicationConfig.fromINI() : serialization of list objects is not implemented.")
                    else:  raise ValueError("Could not convert parameter %s. Oops. Looks like an error in the program." % name)
                except ValueError:
                    raise ValueError("Error in configuration: Parameter %s should be of type %s." % (name,type(defaultvalue) ))

                if name == 'network.http.proxy.auth.password':
                    obj =  self._ungarble(obj)  # Ungarbles the password.

                if obj != None:
                    self[name] = obj
            else:
                # else store this unknown parameter as string
                self[name] = value

    def loadFromRegistryCurrentUser(self):
        ''' Load configuration from Windows registry. '''
        # We manually build a .INI file in memory from the registry.
        inilines = ['[%s]' % settings.CONFIG_SECTIONNAME]
        try:
            import winreg
        except ImportError as exc:
            raise ImportError("applicationConfig.loadFromRegistryCurrentUser() can only be used under Windows (requires the _winreg module).\nCould not import module because: %s" % exc)
        try:
            key = winreg.OpenKey( winreg.HKEY_CURRENT_USER, settings.CONFIG_REGPATH,0, winreg.KEY_READ)
            # Now get all values in this key:
            i = 0
            try:
                while True:
                    valueobj = winreg.EnumValue(key,i) # mmm..strange, Should unpack to 3 values, but seems to unpack to more.  Bug of EnumValue() ?
                    valuename = str(valueobj[0]).strip()
                    valuedata = str(valueobj[1]).strip()
                    valuetype = valueobj[2]
                    if valuetype != winreg.REG_SZ:
                        raise TypeError("The registry value %s does not have the correct type (REG_SZ). Please delete it." % valuename)
                    else:
                        if valuename not in settings.NONEXPORTABLE_PARAMETERS:
                            inilines += [ '%s=%s' % (valuename,str(valuedata)) ]  # Build the .INI file.
                    i += 1
            except EnvironmentError:
                pass  # EnvironmentError means: "No more values to read". We simply exit the 'While True' loop.
            self.fromINI('\n'.join(inilines))   # Then parse the generated .INI file.
        except EnvironmentError:
            raise WindowsError("Could not read configuration from registry !")
        winreg.CloseKey(key)

    def saveToRegistryCurrentUser(self):
        ''' Save configuration to Windows registry. '''
        # Note: this uses the output of self.toINI()
        # This method expects the .INI file to contain a single section,
        # started on first line, and no comments.
        # eg.[webGobbler]
        #    assembler.emboss = False
        #    assembler.sizex = 1024
        try:
            import winreg
        except ImportError as exc:
            raise ImportError("applicationConfig.saveToRegistryCurrentUser() can only be used under Windows (requires the _winreg module).\nCould not import module because: %s" % exc)
        try:
            key = winreg.CreateKey(winreg.HKEY_CURRENT_USER, settings.CONFIG_REGPATH)  # Create or open existing key
            for line in self.toINI().split('\n')[1:]:
                pname = line.split('=')[0]                # pname    : everything before the first =
                strvalue = '='.join(line.split('=')[1:])  # strvalue : everything after the first =
                winreg.SetValueEx(key, pname.strip(),0, winreg.REG_SZ, strvalue.strip())
        except EnvironmentError:
            raise WindowsError("Could not write configuration to registry !")
        winreg.CloseKey(key)

    def saveToFileInUserHomedir(self):
        ''' Save the configuration in .webGobblerConf in user's home dir. '''
        # Mainly for Unix/Linux. Windows users will probably prefer saveToRegistryCurrentUser()
        inidata = self.toINI()
        userhomedir = os.path.expanduser('~')  # Get user home directory.
        filepath = os.path.join(userhomedir,settings.CONFIG_FILENAME)
        file = open(filepath,"w+b")
        file.write(inidata)
        file.close()

    def configFilename(self):
        ''' Returns the absolute path where the .ini file is supposed to be read/saved. '''
        return os.path.join(os.path.expanduser('~'),settings.CONFIG_FILENAME)

    def loadFromFileInUserHomedir(self):
        ''' Loads the configuration from .webGobblerConf in user's home dir. '''
        # Mainly for Unix/Linux. Windows users will probably prefer loadFromRegistryCurrentUser()
        userhomedir = os.path.expanduser('~')  # Get user home directory.
        filepath = os.path.join(userhomedir,settings.CONFIG_FILENAME)
        file = open(filepath,"rb")
        inidata = file.read(50000)
        file.close()
        self.fromINI(inidata)

    def _garble(self, text):
        ''' Returns a garbled version of a string. '''
        # This is no replacement for a good cipher !
        # text IS NOT ENCRYPTED. Is it only self-garbled.
        h=hashlib.sha1(text).digest()
        hk=h*int(len(text)/20+1)
        et=''.join([chr(ord(text[i])^ord(hk[i])) for i in range(len(text))])
        return binascii.hexlify(h+et)

    def _ungarble(self, text):
        ''' Un-garbles the text garbled with _garble(). '''
        d=binascii.unhexlify(text)
        (h,t)=(d[0:20],d[20:])
        hk=h*int(len(t)/20+1)
        return ''.join([chr(ord(t[i])^ord(hk[i])) for i in range(len(t))])

