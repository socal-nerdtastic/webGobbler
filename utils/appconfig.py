#!/usr/bin/python3

import re
import configparser
import io
import os
import hashlib
import binascii

import settings

class applicationConfig(dict):
    ''' An object capable of storing program configuration (in the form of a dictionnary).
        This class is not generic and is tailored to webGobbler.

        It behaves like a dictionnary object, but it also has
        methods to save/load to/from .INI, file and Windows registry.
        Note that this dictionnary only supports:
          - key which are strings.
          - values which are strings, integers or booleans.
        Using other types will raise errors.
        Some keys are special case (specific (de)serialization).

        Example:
           myconfig = applicationConfig()     # Create a configuration (with default values)
           myconfig["pool.nbimages"] = 100    # Change the value of an existing parameter.
           myconfig["myparameter"] = "toto"   # Add a new parameter
           myconfig.saveToFileInUserHomedir() # save to file.

           conf2 = applicationConfig()
           conf2.loadFromFileInUserHomedir()    # Load previous saved file.
           print conf2["pool.nbimages"]         # This displays 100
           print conf2["myparameter"] = "toto"  # This displays "toto"
           print conf2["pool.keepimages"]
    '''

    # Default configuration:
    # This dictionnary contains the default configuration of the whole program.
    # Each class/thread will read an instance of this class to get its parameters.
    # The instance will be altered by the main() according to command-line parameters.
    # (key=parameter name, value=value of this parameter)


    def __init__(self):
        dict.__init__(self)
        self.data = {}
        self.update( settings.DEFAULTCONFIG ) # Start with default configuration:

    def __setitem(self,key,value):
        if not isinstance(key,str):
            raise TypeError("applicationConfig only accepts strings as keys.")

        self.data[key] = value   # Store the value

        # Recompile the regular expressions if the list of blacklisted URL is changed.
        # (We also bock assignment to blacklist.url_re.)
        if key in ('blacklist.url', 'blacklist.url_re'):
            self.data['blacklist.url_re'] = []
            for s in value:
                # We escape all characters in s, except * which we replace with .+?
                # We also add an implicit .+? at end.
                # Example: 'http://*.xiti.com/'  -->  'http\:\/\/.+?\.xiti\.com\/.+?'
                if not s.endswith('*'):     s += '*'
                s = '.+?'.join([re.escape(ss) for ss in s.split('*')])
                self.data['blacklist.url_re'].append( re.compile(s,re.IGNORECASE) )

    def toINI(self):
        ''' Outputs the configuration as a .INI file.
            Output: a string containing the configuration.
        '''
        cp = configparser.ConfigParser()
        cp.add_section(settings.CONFIG_SECTIONNAME)
        # Export all parameters, except the non-exportable ones.
        for key in self:
            if key not in settings.NONEXPORTABLE_PARAMETERS:
                # Serialize some special parameters:
                if key == 'network.http.proxy.auth.password':
                    cp.set(settings.CONFIG_SECTIONNAME,key,self._garble(self[key])) # Garble the password.
                elif key == 'blacklist.imagesha1':  # Serialize the list of blacklisted images
                    cp.set(settings.CONFIG_SECTIONNAME,key,'|'.join(list(self[key].keys())))
                elif key == 'blacklist.url':  # Serialize the list of blacklisted URLs
                    cp.set(settings.CONFIG_SECTIONNAME,key,'|'.join([url.replace('%','%%') for url in self[key]]))
                    # (For ConfigParser, % must be escaped to %%)
                else:  # else, simply store the parameter as is.
                    cp.set(settings.CONFIG_SECTIONNAME,key,str(self[key]))

        # ConfigParser can only write to a file --> create a pseudo-file (inifile)
        inifile = io.StringIO()
        cp.write(inifile)
        data = inifile.getvalue()
        inifile.close()

        # Beautify the file by sorting parameters:
        lines = data.split('\n')
        sectionname = [lines[0]]   # The [webGobbler] section delimiter
        parameters = lines[1:]     # The parameters below
        parameters = [p for p in parameters if len(p.strip())>0]  # remove empty lines generated by configparser
        parameters.sort()
        data = '\n'.join(sectionname+parameters)
        return data

    def fromINI(self, inidata):
        ''' Imports configuration from a .INI file.
            inidata : a string containing the .INI file.
        '''
        cp = configparser.ConfigParser()
        cp.read_string(inidata)  # FIXME: try/catch ConfigParser exceptions ?
        for (name, value) in cp.items(settings.CONFIG_SECTIONNAME):

            doCoerceType = True
            if name == 'blacklist.imagesha1':
                # Deserialize the list of sha1  (  'xxxx,yyy,zzz' --> ['xxx','yyy','zzz'])
                value = dict([ (v,0) for v in value.split('|')])
                doCoerceType = False  # We already manually coerced the type of this parameter.
            elif name == 'blacklist.url':
                # Deserialize the list of URLs
                value = value.split('|')
                doCoerceType = False  # We already manually coerced the type of this parameter.

            if name in settings.DEFAULTCONFIG and doCoerceType:
                # If parameter exists in default parameters, coerce its type.
                defaultvalue = settings.DEFAULTCONFIG[name]
                obj = None
                try:
                    if isinstance(defaultvalue,str): obj = str(value).strip()
                    elif isinstance(defaultvalue,bool):
                        if str(value).lower()=='true': obj = True
                        else: obj = False
                    elif isinstance(defaultvalue,int):  obj = int(value)
                    elif isinstance(defaultvalue,float):  obj = float(value)
                    elif isinstance(value,dict): raise NotImplementedError("applicationConfig.fromINI() : serialization of dictionary objects is not implemented.")
                    elif isinstance(value,list): raise NotImplementedError("applicationConfig.fromINI() : serialization of list objects is not implemented.")
                    else:  raise ValueError("Could not convert parameter %s. Oops. Looks like an error in the program." % name)
                except ValueError:
                    raise ValueError("Error in configuration: Parameter %s should be of type %s." % (name,type(defaultvalue) ))

                if name == 'network.http.proxy.auth.password':
                    obj =  self._ungarble(obj)  # Ungarbles the password.

                if obj != None:
                    self[name] = obj
            else:
                # else store this unknown parameter as string
                self[name] = value

    def saveToFileInUserHomedir(self):
        ''' Save the configuration in .webGobblerConf in user's home dir. '''
        inidata = self.toINI()
        filepath = self.configFilename()
        with open(filepath,"w") as f:
            f.write(inidata)

    def configFilename(self):
        ''' Returns the absolute path where the .ini file is supposed to be read/saved. '''
        return os.path.join(os.path.expanduser('~'),settings.CONFIG_FILENAME)

    def loadFromFileInUserHomedir(self):
        ''' Loads the configuration from .webGobblerConf in user's home dir. '''
        filepath = self.configFilename()
        with open(filepath,"r") as f:
            inidata = f.read(50000)
        self.fromINI(inidata)

    def _garble(self, text):
        ''' Returns a garbled version of a string. '''
        # This is no replacement for a good cipher !
        # text IS NOT ENCRYPTED. Is it only self-garbled.
        h=hashlib.sha1(text.encode()).digest()
        hk=h*int(len(text)/20+1)
        et=bytearray(ord(text[i])^hk[i] for i in range(len(text)))
        return binascii.hexlify(h+et).decode()

    def _ungarble(self, text):
        ''' Un-garbles the text garbled with _garble(). '''
        d=binascii.unhexlify(text)
        (h,t)=(d[0:20],d[20:])
        hk=h*int(len(t)/20+1)
        return ''.join([chr(t[i]^hk[i]) for i in range(len(t))])


